

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>           /* Definition of AT_* constants */
#include <errno.h>
#include <stdatomic.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>

#define SUCCESS 1
#define FAILURE -1
#define TRUE 1
#define FALSE 0
#define ARGUMENTS_NUM 4
 
//Those defines act like a functions - letting us to execute more than one line in a define
#define handle_error_en(en, msg) \
        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

#define handle_thread_error(msg) \
        do { perror(msg); pthread_exit((void*)EXIT_FAILURE); } while (0)

#define handle_error(msg) \
        do { perror(msg); exit(1); } while (0)

#define print_permission_error(path) \
        do { printf("Directory %s: Permission denied.\n", path); } while (0)

#define print_errno() \
        do { printf("Oh dear, something went wrong %s\n", strerror(errno)); } while (0)


typedef struct _dir_node{
	char *name;
	struct _dir_list *next;
	struct _dir_list *previous;
}dir_node;

typedef struct _dir_queue{
	dir_node *head;
	dir_node *tail;
	int size;
}dir_queue;

typedef struct _thread_node{
	pthread_t thread;
	struct _thread_node *next;
}t_node;

typedef struct _threads_list{
	t_node *head;
	int size;
}t_list;

/*******************
 # global vaiables #
###################*/
static struct sigaction sig_interrupt;
static int starting_thread_counter;
static int waiting_threads_counter;
int EXIT_FLAG;									// indicating exiting condition initialize to zero because of the static keyword
int SIGNAL_FLAG;								// sending signal indication
static char *SEARCH_TERM;
static long THREAD_NUM;
//int number_of_found;							// number of terms found			
static dir_queue queue;                        // global directory queue
static pthread_mutex_t mutex_thread_list;		// protecting critical segment while doing operations on thread_list
static pthread_mutex_t mutex_queue_operations;	// protecting critical segment while doing queue operations
static pthread_cond_t cv_start_searching;          // condition variable to start the threads 
static pthread_cond_t cv_wait_for_work;             // condition variable to indicate waiting for work threads
static t_list th_list;							// global threads list
static atomic_int number_of_found;


void prepare_threads(void){

	int rc;
	for(long thread_number = 0; thread_number < THREAD_NUM; thread_number++){
		t_node *current_t_node = (t_node*)calloc(1, sizeof(t_node));
		if(NULL == current_t_node) handle_error("calloc failed"); // this is error in the main thread - exiting
		if(0 == thread_number){ //first node to insert to list.
			th_list.head = current_t_node;
			th_list.size++;
		}
		else{ //not the first node to insert
			current_t_node->next = th_list.head;
			th_list.head = current_t_node;
			th_list.size++;
		}
		rc = pthread_create(&(current_t_node->thread), NULL, (void*)dir_worm, (void *)current_t_node); 
		if(0 != rc) handle_error("pthread_create failed"); // error in main thread - exiting
		//adding this thread to the 'start_searching cv . using while statement due to the fact that I want to wait until all threads will wait in the dir_worm function and than execute them all simultaneaously 
		while(THREAD_NUM != starting_thread_counter){
			pthread_cond_broadcast(&cv_start_searching);
		}
	}

}
/*These three arguments are as follows

       sig    The number of the signal that caused invocation of the
              handler.

       info   A pointer to a siginfo_t, which is a structure containing
              further information about the signal, as described below.

       ucontext
              This is a pointer to a ucontext_t structure, cast to
              void *.  The structure pointed to by this field contains
              signal context information that was saved on the user-
              space stack by the kernel; for details, see sigreturn(2).
              Further information about the ucontext_t structure can be
              found in getcontext(3) and signal(7).  Commonly, the
              handler function doesn't make any use of the third
              argument.*/

void signal_termination_indication(int sig, siginfo_t* info, void *ucontext){
	//i dont reaalt care about the arguments because im just changing 2 simple flags
    EXIT_FLAG = 1;
	SIGNAL_FLAG = 1;
}

void loading_signal_handler(void){
	/*If SA_SIGINFO is specified in sa_flags, then sa_sigaction
       (instead of sa_handler) specifies the signal-handling function
       for signum.*/
    sig_interrupt.sa_flags = SA_SIGINFO;
	/*specifying the action*/
    sig_interrupt.sa_sigaction = signal_termination_indication;
	/* Interrupt (ANSI).  */
	/*returns 0 on success; on error, -1 is returned, and
       errno is set to indicate the error.*/
    if(0 != sigaction(SIGINT, &sig_interrupt, NULL)) handle_error("sigaction FAILURE"); 
}
void initialize_queue(dir_node *root_node){
	queue.head = root_node;
	queue.tail = root_node;
	queue.size = 1;
}
dir_node* initial_state(char *path){
	dir_node *new_dir_node = create_dir_node(path);
	queue.head = new_dir_node;
	queue.tail = new_dir_node;
	queue.size = 1;
}
dir_node* create_dir_node(char *path){
	dir_node *new_dir_node = (dir_node*)calloc(1, sizeof(dir_node));
	if(NULL == new_dir_node) //calloc failed 
		return NULL;
	new_dir_node->next = NULL;
	new_dir_node->previous = NULL;
	new_dir_node->name = path;
	return new_dir_node;
}

void enqueue(dir_node *new_node){
	pthread_mutex_lock(&mutex_queue_operations);
	if(0 != queue.size){ // this is not the fist element to insert
		new_node->previous = queue.tail;
		queue.tail->next = new_node;
		queue.tail = new_node;
		queue.size++;
	}
	else{ // maybe this is the first element
		queue.head = new_node;
		queue.tail = new_node;
		queue.size = 1;

	}
	pthread_cond_signal(&cv_wait_for_work); // this cv signalling that new thread enqueue and someone can treat this directory
	pthread_mutex_unlock(&mutex_queue_operations);
}

/*The typical usage pattern of condition variables is
// safely examine the condition, prevent other threads from
// altering it
pthread_mutex_lock (&lock);
while ( SOME-CONDITION is false)
    pthread_cond_wait (&cond, &lock);

// Do whatever you need to do when condition becomes true
do_stuff();
pthread_mutex_unlock (&lock);
On the other hand, a thread, signaling the condition variable, typically looks like

// ensure we have exclusive access to whathever comprises the condition
pthread_mutex_lock (&lock);
ALTER-CONDITION
// Wakeup at least one of the threads that are waiting on the condition (if any)
pthread_cond_signal (&cond);

// allow others to proceed
pthread_mutex_unlock (&lock)*/
dir_node* dequeue(){
	pthread_mutex_lock(&mutex_queue_operations);
	while(0 == queue.size){
		//checking if some other thread raise the EXIT_FLAG to check for termination signal
		is_terminating();
		if(TRUE == EXIT_FLAG){
			pthread_mutex_unlock(&mutex_queue_operations);
			return NULL; //exiting this thread from being dequeue 
		}
		waiting_threads_counter++; // protected under mutex_queue_operations from race conditions
		pthread_cond_wait(&cv_wait_for_work, &mutex_queue_operations); /* the wait function unlock the mutex. when signal is called on some thread it continue with the corresponding thread on the next line, furthermore when the thread that blocked by this cv get signalled he aquire the mutex from the signalled thread and lock the mutex again.*/
		waiting_threads_counter--; //here the thread continue so decrement the waiting signal number by one
		//in this point things could be change since the last check for the exit status
		if(TRUE == EXIT_FLAG){
			pthread_mutex_unlock(&mutex_queue_operations); //releasing lock before moving forward
			return NULL;
		}
	}
	dir_node *popped = queue.head;
	popped->next = NULL;
	if(TRUE != queue.size){ // this is not the last element within the queue
		queue.size--;
		queue.head = queue.head->next;
		queue.head->previous = NULL;
	}
	else{ //this is the first argument
		queue.size = 0;
		queue.head = NULL;
		queue.tail = NULL;
	}
	pthread_mutex_unlock(&mutex_queue_operations);
	return popped;

}
/*The program exits in one of the following cases: (1) there are no more directories in the queue and
all searching threads are idle (not searching for content within a directory), or (2) all searching
threads have died due to an error. The exit conditions and handling are detailed below.*/
int is_terminating(){
	if((0 == queue.size) && (th_list.size == waiting_threads_counter + 1)) EXIT_FLAG = TRUE; // the program should exit thats why we set EXIT_FLAG to TRUE
	return EXIT_FLAG;
}
/******************************************************************** 
struct dirent {
    ino_t d_ino;  inode number 
    off_t d_off;  offset to the next dirent 
    unsigned short d_reclen; length of this record 
    unsigned char d_type; type of file 
    char d_name[256];  filename 
};
***********************************************************************/
/**********************************************************************
 * struct stat {
               dev_t     st_dev;         ID of device containing file 
               ino_t     st_ino;         inode number 
               mode_t    st_mode;        file type and mode 
               nlink_t   st_nlink;       number of hard links 
               uid_t     st_uid;         user ID of owner 
               gid_t     st_gid;         group ID of owner 
               dev_t     st_rdev;        device ID (if special file)
               off_t     st_size;        total size, in bytes 
               blksize_t st_blksize;     blocksize for filesystem I/O
               blkcnt_t  st_blocks;      number of 512B blocks allocated
           };
 ***********************************************************************/
/**********************************************************************
 The following flags are defined for the st_mode field:

   S_IFMT     0170000   bitmask for the file type bitfields
   S_IFSOCK   0140000   socket
   S_IFLNK    0120000   symbolic link
   S_IFREG    0100000   regular file
   S_IFBLK    0060000   block device
   S_IFDIR    0040000   directory
   S_IFCHR    0020000   character device
   S_IFIFO    0010000   FIFO
   S_ISUID    0004000   set UID bit
   S_ISGID    0002000   set-group-ID bit (see below)
   S_ISVTX    0001000   sticky bit (see below)
   S_IRWXU    00700     mask for file owner permissions
   S_IRUSR    00400     owner has read permission
   S_IWUSR    00200     owner has write permission
   S_IXUSR    00100     owner has execute permission
   S_IRWXG    00070     mask for group permissions
   S_IRGRP    00040     group has read permission
   S_IWGRP    00020     group has write permission
   S_IXGRP    00010     group has execute permission
   S_IRWXO    00007     mask for permissions for others (not in group)
   S_IROTH    00004     others have read permission
   S_IWOTH    00002     others have write permission
   S_IXOTH    00001     others have execute permission
   ***********************************************************************/
 /*len = strlen(name);
dirp = opendir(".");
while ((dp = readdir(dirp)) != NULL)
        if (dp->d_namlen == len && !strcmp(dp->d_name, name)) {
                (void)closedir(dirp);
                return FOUND;
        }
(void)closedir(dirp);
return NOT_FOUND;*/


/*DIR* tableDir = opendir(buf);
struct dirent* getInfo;

readdir(tableDir); // ignore '.'
readdir(tableDir); // ignore '..'

i = 0;
while(1)
{


    getInfo = readdir(tableDir);
    if (getInfo == 0)
        break;
    strcpy(arr[i++], getInfo->d_name);
}
*(num_keys) = i;
return arr;
}*/
int is_dot_or_double_dot(char *filename){
	return (strcmp(filename, ".") == 0 || strcmp(filename, "..") == 0) ? TRUE : FALSE;
}

void* dir_worm(void *arg){
	t_node *thread_node;
	dir_node *dequeue_node;
	DIR *dir;
	struct dirent *file_information;
	struct stat file_status;

	//here im locking the thread list in order to call the cv for the accumulation of the threads that are being ready to work
	//Furthermore incrementing the counter of ready threads
	pthread_mutex_lock(&mutex_thread_list);
	pthread_cond_wait((&cv_start_searching), &mutex_thread_list);
	starting_thread_counter++;
	pthread_mutex_unlock(&mutex_thread_list);
	while(FALSE == EXIT_FLAG){ //iterating as long as exit_flag is FALSE == 0
		if(TRUE == is_terminating()) break; // first checking wheter I have to continue or quite from that thread
		thread_node = (t_node*)arg; //threads taking void pointers as argument so I have to cast
		if(NULL == (dequeue_node = dequeue())) break;
		if (NULL == (dir = opendir(dequeue_node->name))) { // checking for opening succeed or permissions of current directory
			// 'opendir' encounter an error
			/* could not open directory */
			if(EACCES == errno){ //EACCES: Search permission is denied for one of the directories in the path prefix of pathname
				print_permission_error(dequeue_node->name);
					free(dequeue_node); //each node allocated dynamically using 'create_dir_node(char *path)'
					continue; //just permmision access denied, I can continue and dont exit thread
			} 
			perror("Cannot open directory... exiting thread");
			pthread_exit((void*)TRUE);
		}	
		/*The  readdir()  function returns a pointer to a dirent structure representing the next directory entry in the directory stream pointed to by dirp.  It returns NULL on reaching the end of the directory stream or if
       an error occurred.*/
		while(NULL != (file_information = readdir(dir)) && FALSE == EXIT_FLAG){ /*iterating the directories as long as EXIT_FLAG allow it and this is not efo as I stated in the man-page*/
			char *current_file_name = file_information->d_name;
			if(TRUE == is_dot_or_double_dot(current_file_name)) continue;
			int rc;
			char *fullpath;
			size_t length = strlen(current_file_name) + strlen(dequeue_node->name) + 1 + 1;
			if(FAILURE == (fullpath = (char*)calloc(length, sizeof(char)))) handle_thread_error("Calloc Error");
			

		}










		

	}

}




	if ((dir = opendir(path)) != NULL) { // dont have to chech here becuase each directory that enter the queue already cheached for permissions.
		readdir(path); // ignore '.'
		readdir(path); // ignore '..'
		/* print all the files and directories within TARGET */
		errno = 0; //set errno to zero in order to see difference while using 'readdir'
		while ((file_information = readdir(dir)) != NULL) {
			lstat(file_information->d_name, &file_status);          //getting a file stats
			char *current_file_name = file_information->d_name; 
			puts(current_file_name);                       		// show current filename
			printf("file mode: %d\n", file_status.st_mode);
			// print what kind of file we are dealing with
			switch (file_status.st_mode & S_IFMT) {
        		case S_IFREG:  
					puts("|| regular file");
					break;
				case S_IFDIR:
					puts("|| directory");
					if(SUCCESS == is_searchable_directory(current_file_name)){
						//here we have to enqueu
					}
					break;
				case S_IFCHR:        
					puts("|| character device");
					break;
				case S_IFBLK:        
					puts("|| block device");
					break;
				case S_IFLNK: 
					puts("|| symbolic link");
					break;
				case S_IFIFO: 
					puts("|| pipe");    
					break;
				case S_IFSOCK:
					puts("|| socket");
					break;
				default:
					puts("|| unknown"); 
		    }
			errno = 0; //set errno to zero in order to see difference while using 'readdir'
		}
		closedir (dir);
		if(0 == errno) return EXIT_SUCCESS; //that means 'readdir' reach end of stream
		else{  //'readdir' encounter an error
			print_errno();
			return FAILURE;
		}
	else { // 'opendir' encounter an error
		/* could not open directory */
		if(EACCES == errno){ //EACCES: Search permission is denied for one of the directories in the path prefix of pathname
			print_permission_error(path);
			return FAILURE;
		} 
		handle_error("cannot-open-file");
	}
}
void concatenate_the_path(char *path, char *addition){
	strcat(path, addition);

}

bool is_searchable(char* path) {
    int res = 0;
    struct stat dir;
    lstat(path, &dir);
    res = S_ISDIR(dir.st_mode);
    return res;
}


int is_searchable_directory(char *path){
	DIR *dir;
    struct stat st;
	int rc, res;
	if (NULL == (dir = opendir(path))) { // 'opendir' encounter an error 
		if(EACCES == errno){ //EACCES Search permission is denied for one of the directories in the path prefix of pathname
			print_permission_error(path);
			closedir(dir);
			return FAILURE;
		}	
		else{
			closedir(dir);
			handle_error("Error while opening directory"); //ALSO EXIT
		} 
    }
	closedir(dir);
	return SUCCESS;
}


int main(int argc, char **argv){

	if(ARGUMENTS_NUM != argc) handle_error("Wrong number of arguments passed"); //ALSO EXIT
	char *ROOT = *(argv + 1);
	int rc;
	SEARCH_TERM = *(argv + 2);
	if(SUCCESS >= (THREAD_NUM = atol(*(argv + 3)))) handle_error("wrong threads number"); //assuming this argument is integer grater than zero
	if(SUCCESS != (rc = is_searchable_directory(ROOT)));
	//signint init
	//init locks
	dir_node *genesis_node = initial_state(ROOT); /*this is the first directory as stated - genesis of things*/
	prepare_threads(); /*here im creating a linked-list of threads in order to free'd them comfortably.*/
	loading_signal_handler();/*here were loading the signal handler for threads*/
	
	return 0;	
}

