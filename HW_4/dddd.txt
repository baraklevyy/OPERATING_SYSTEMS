

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>           /* Definition of AT_* constants */
#include <errno.h>

#define SUCCESS 1
#define FAILURE -1
#define TRUE 1
#define FALSE 0
#define ARGUMENTS_NUM 4
 
//Those defines act like a functions - letting us to execute more than one line in a define
#define handle_error_en(en, msg) \
        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

#define handle_error(msg) \
        do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define print_permission_error(path) \
        do { printf("Directory %s: Permission denied.\n", path); } while (0)

#define print_errno() \
        do { printf("Oh dear, something went wrong %s\n", strerror(errno)); } while (0)


typedef struct _dir_node{
	char *name;
	struct _dir_list *next;
	struct _dir_list *previous;
}dir_node;

typedef struct _dir_queue{
	dir_node *head;
	dir_node *tail;
	int size;
}dir_queue;

typedef struct _thread_node{
	pthread_t thread;
	struct _thread_node *next;
}t_node;

typedef struct _threads_list{
	t_node *head;
	int size;
}t_list;

/*******************
 # global vaiables #
###################*/
static int starting_thread_counter;
static int waiting_threads_counter;
int EXIT_FLAG;									// indicating exiting condition initialize to zero because of the static keyword
int SIGNAL_FLAG;								// sending signal indication
int number_of_found;							// number of terms found			
static dir_queue queue;                        // global directory queue
static pthread_mutex_t mutex_thread_list;		// protecting critical segment while doing operations on thread_list
static pthread_mutex_t mutex_queue_operations;	// protecting critical segment while doing queue operations
static pthread_mutex_t mutex_found_increment;    // macking found increment atomic
static pthread_cond_t cv_start_searching;          // condition variable to start the threads 
static pthread_cond_t cv_wait_for_work;             // condition variable to indicate waiting for work threads
static t_list th_list;							// global threads list



void prepare_threads(long THREAD_NUM){

	int rc;
	for(long thread_number = 0; thread_number < THREAD_NUM; thread_number++){
		t_node *current_t_node = (t_node*)calloc(1, sizeof(t_node));
		if(NULL == current_t_node) handle_error("calloc failed"); // this is error in the main thread - exiting
		if(0 == thread_number){ //first node to insert to list.
			th_list.head = current_t_node;
			th_list.size++;
		}
		else{ //not the first node to insert
			current_t_node->next = th_list.head;
			th_list.head = current_t_node;
			th_list.size++;
		}
		rc = pthread_create(&(current_t_node->thread), NULL, (void*)dir_worm, (void *)current_t_node); 
		if(0 != rc) handle_error("pthread_create failed"); // error in main thread - exiting
		//adding this thread to the 'start_searching cv . using while statement due to the fact tha this segment is not thread-safe 
		while(THREAD_NUM != starting_thread_counter){
			pthread_cond_broadcast(&cv_start_searching);
		}
	}

}


void initialize_queue(dir_node *root_node){
	queue.head = root_node;
	queue.tail = root_node;
	queue.size = 1;
}

dir_node* create_dir_node(char *path){
	dir_node *new_dir_node = (dir_node*)calloc(1, sizeof(dir_node));
	if(NULL == new_dir_node) //calloc failed 
		return NULL;
	new_dir_node->next = NULL;
	new_dir_node->previous = NULL;
	new_dir_node->name = path;
	return new_dir_node;
}

void enqueue(dir_node *new_node){
	pthread_mutex_lock(&mutex_queue_operations);
	if(0 != queue.size){ // this is not the fist element to insert
		new_node->previous = queue.tail;
		queue.tail->next = new_node;
		queue.tail = new_node;
		queue.size++;
	}
	else{ // maybe this is the first element
		queue.head = new_node;
		queue.tail = new_node;
		queue.size = 1;

	}
	pthread_cond_signal(&cv_wait_for_work); // this cv signalling that new node enqueue and someone can treat this directory
	pthread_mutex_unlock(&mutex_queue_operations);
}
/*The typical usage pattern of condition variables is
// safely examine the condition, prevent other threads from
// altering it
pthread_mutex_lock (&lock);
while ( SOME-CONDITION is false)
    pthread_cond_wait (&cond, &lock);

// Do whatever you need to do when condition becomes true
do_stuff();
pthread_mutex_unlock (&lock);
On the other hand, a thread, signaling the condition variable, typically looks like

// ensure we have exclusive access to whathever comprises the condition
pthread_mutex_lock (&lock);
ALTER-CONDITION
// Wakeup at least one of the threads that are waiting on the condition (if any)
pthread_cond_signal (&cond);

// allow others to proceed
pthread_mutex_unlock (&lock)*/
dir_node* dequeue(){
	pthread_mutex_lock(&mutex_queue_operations);
	while(0 == queue.size){
		is_terminating();
		if(TRUE == EXIT_FLAG){
			pthread_mutex_unlock(&mutex_queue_operations);
			return NULL;
		}
		waiting_threads_counter++;
		pthread_cond_wait(&cv_wait_for_work, &mutex_queue_operations); /* the wait function unlock the mutex. when signal is called we continue with the corresponding thread on the next line, furthermore when the thread that blocked by this cv get signalled he aquire the mutex from the signalled thread and lock the mutex again.*/
		waiting_threads_counter--;
		//in this point things could be change since the last check for the exit status
		if(TRUE == EXIT_FLAG){
			pthread_mutex_unlock(&mutex_queue_operations);
			return NULL;
		}
	}
	dir_node *popped = queue.head;
	popped->next = NULL;
	if(TRUE != queue.size){ // this is not the last element within the queue
		queue.size--;
		queue.head = queue.head->next;
		queue.head->previous = NULL;
	}
	else{ //this is the first argument
		queue.size = 0;
		queue.head = NULL;
		queue.tail = NULL;
	}
	pthread_mutex_unlock(&mutex_queue_operations);
	return popped;

}
/*The program exits in one of the following cases: (1) there are no more directories in the queue and
all searching threads are idle (not searching for content within a directory), or (2) all searching
threads have died due to an error. The exit conditions and handling are detailed below.*/
void is_terminating(){
	if((0 == queue.size) && (th_list.size == waiting_threads_counter + 1)) EXIT_FLAG = TRUE; // the program should exit thats why we set EXIT_FLAG to TRUE
}
/******************************************************************** 
struct dirent {
    ino_t d_ino;  inode number 
    off_t d_off;  offset to the next dirent 
    unsigned short d_reclen; length of this record 
    unsigned char d_type; type of file 
    char d_name[256];  filename 
};
***********************************************************************/
/**********************************************************************
 * struct stat {
               dev_t     st_dev;         ID of device containing file 
               ino_t     st_ino;         inode number 
               mode_t    st_mode;        file type and mode 
               nlink_t   st_nlink;       number of hard links 
               uid_t     st_uid;         user ID of owner 
               gid_t     st_gid;         group ID of owner 
               dev_t     st_rdev;        device ID (if special file)
               off_t     st_size;        total size, in bytes 
               blksize_t st_blksize;     blocksize for filesystem I/O
               blkcnt_t  st_blocks;      number of 512B blocks allocated
           };
 ***********************************************************************/
/**********************************************************************
 The following flags are defined for the st_mode field:

   S_IFMT     0170000   bitmask for the file type bitfields
   S_IFSOCK   0140000   socket
   S_IFLNK    0120000   symbolic link
   S_IFREG    0100000   regular file
   S_IFBLK    0060000   block device
   S_IFDIR    0040000   directory
   S_IFCHR    0020000   character device
   S_IFIFO    0010000   FIFO
   S_ISUID    0004000   set UID bit
   S_ISGID    0002000   set-group-ID bit (see below)
   S_ISVTX    0001000   sticky bit (see below)
   S_IRWXU    00700     mask for file owner permissions
   S_IRUSR    00400     owner has read permission
   S_IWUSR    00200     owner has write permission
   S_IXUSR    00100     owner has execute permission
   S_IRWXG    00070     mask for group permissions
   S_IRGRP    00040     group has read permission
   S_IWGRP    00020     group has write permission
   S_IXGRP    00010     group has execute permission
   S_IRWXO    00007     mask for permissions for others (not in group)
   S_IROTH    00004     others have read permission
   S_IWOTH    00002     others have write permission
   S_IXOTH    00001     others have execute permission
   ***********************************************************************/
 /*len = strlen(name);
dirp = opendir(".");
while ((dp = readdir(dirp)) != NULL)
        if (dp->d_namlen == len && !strcmp(dp->d_name, name)) {
                (void)closedir(dirp);
                return FOUND;
        }
(void)closedir(dirp);
return NOT_FOUND;*/


/*DIR* tableDir = opendir(buf);
struct dirent* getInfo;

readdir(tableDir); // ignore '.'
readdir(tableDir); // ignore '..'

i = 0;
while(1)
{


    getInfo = readdir(tableDir);
    if (getInfo == 0)
        break;
    strcpy(arr[i++], getInfo->d_name);
}
*(num_keys) = i;
return arr;
}*/

void* dir_worm(void *arg){
	DIR *dir;
	struct dirent *file_information;
	struct stat file_status;




	if ((dir = opendir(path)) != NULL) { // dont have to chech here becuase each directory that enter the queue already cheached for permissions.
		readdir(path); // ignore '.'
		readdir(path); // ignore '..'
		/* print all the files and directories within TARGET */
		errno = 0; //set errno to zero in order to see difference while using 'readdir'
		while ((file_information = readdir(dir)) != NULL) {
			lstat(file_information->d_name, &file_status);          //getting a file stats
			char *current_file_name = file_information->d_name; 
			puts(current_file_name);                       		// show current filename
			printf("file mode: %d\n", file_status.st_mode);
			// print what kind of file we are dealing with
			switch (file_status.st_mode & S_IFMT) {
        		case S_IFREG:  
					puts("|| regular file");
					break;
				case S_IFDIR:
					puts("|| directory");
					if(SUCCESS == is_searchable_directory(current_file_name)){
						//here we have to enqueu
					}
					break;
				case S_IFCHR:        
					puts("|| character device");
					break;
				case S_IFBLK:        
					puts("|| block device");
					break;
				case S_IFLNK: 
					puts("|| symbolic link");
					break;
				case S_IFIFO: 
					puts("|| pipe");    
					break;
				case S_IFSOCK:
					puts("|| socket");
					break;
				default:
					puts("|| unknown"); 
		    }
			errno = 0; //set errno to zero in order to see difference while using 'readdir'
		}
		closedir (dir);
		if(0 == errno) return EXIT_SUCCESS; //that means 'readdir' reach end of stream
		else{  //'readdir' encounter an error
			print_errno();
			return FAILURE;
		}
	}
	else { // 'opendir' encounter an error
		/* could not open directory */
		if(EACCES == errno){ //EACCES: Search permission is denied for one of the directories in the path prefix of pathname
			print_permission_error(path);
			return FAILURE;
		} 
		handle_error("cannot-open-file");
	}
}

int is_searchable_directory(char *path){
	DIR *dir;
    struct stat st;
	int rc, res;
	if (NULL == (dir = opendir(path))) { // 'opendir' encounter an error 
		if(EACCES == errno){ //EACCES Search permission is denied for one of the directories in the path prefix of pathname
			print_permission_error(path);
			return FAILURE;
		}	
		else handle_error("Error while opening directory");
    }
	return SUCCESS;

int main(int argc, char **argv){
	if(ARGUMENTS_NUM != argc) handle_error("Wrong number of arguments passed");
	char *ROOT = *(argv + 1);
	long THREAD_NUMNBER;
	int rc;
	char *TERM = *(argv + 2);
	if(SUCCESS >= (THREAD_NUMNBER = atol(*(argv + 3)))) handle_error("NUMBER OF THREADS CANNOT CONVETED INTO DECIMAL NUMBER"); //assuming this argument is integer grater than zero
	if(SUCCESS != (rc = is_readable_file(ROOT)));
	rc = dir_worm(ROOT);

	return 0;	
}

