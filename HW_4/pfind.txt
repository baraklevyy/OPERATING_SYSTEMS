

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>           /* Definition of AT_* constants */
#include <errno.h>

#define SUCCESS 1
#define FAILURE -1
#define ARGUMENTS_NUM 4
 
//Those defines act like a functions - letting us to execute more than one line in a define
#define handle_error_en(en, msg) \
        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

#define handle_error(msg) \
        do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define print_permission_error(path) \
        do { printf("Directory %s: Permission denied.\n", path); } while (0)

#define print_errno() \
        do { printf("Oh dear, something went wrong %s\n", strerror(errno)); } while (0)


typedef struct _dir_node{
	char *name;
	struct _dir_list *next;
	struct _dir_list *previous;
}dir_list;

typedef struct _dir_queue{
	dir_list *head;
	dir_list *tail;
	int size;
}dir_queue;
/******************************************************************** 
struct dirent {
    ino_t d_ino;  inode number 
    off_t d_off;  offset to the next dirent 
    unsigned short d_reclen; length of this record 
    unsigned char d_type; type of file 
    char d_name[256];  filename 
};
***********************************************************************/
/**********************************************************************
 * struct stat {
               dev_t     st_dev;         ID of device containing file 
               ino_t     st_ino;         inode number 
               mode_t    st_mode;        file type and mode 
               nlink_t   st_nlink;       number of hard links 
               uid_t     st_uid;         user ID of owner 
               gid_t     st_gid;         group ID of owner 
               dev_t     st_rdev;        device ID (if special file)
               off_t     st_size;        total size, in bytes 
               blksize_t st_blksize;     blocksize for filesystem I/O
               blkcnt_t  st_blocks;      number of 512B blocks allocated
           };
 ***********************************************************************/
/**********************************************************************
 The following flags are defined for the st_mode field:

   S_IFMT     0170000   bitmask for the file type bitfields
   S_IFSOCK   0140000   socket
   S_IFLNK    0120000   symbolic link
   S_IFREG    0100000   regular file
   S_IFBLK    0060000   block device
   S_IFDIR    0040000   directory
   S_IFCHR    0020000   character device
   S_IFIFO    0010000   FIFO
   S_ISUID    0004000   set UID bit
   S_ISGID    0002000   set-group-ID bit (see below)
   S_ISVTX    0001000   sticky bit (see below)
   S_IRWXU    00700     mask for file owner permissions
   S_IRUSR    00400     owner has read permission
   S_IWUSR    00200     owner has write permission
   S_IXUSR    00100     owner has execute permission
   S_IRWXG    00070     mask for group permissions
   S_IRGRP    00040     group has read permission
   S_IWGRP    00020     group has write permission
   S_IXGRP    00010     group has execute permission
   S_IRWXO    00007     mask for permissions for others (not in group)
   S_IROTH    00004     others have read permission
   S_IWOTH    00002     others have write permission
   S_IXOTH    00001     others have execute permission
   ***********************************************************************/
 /*len = strlen(name);
dirp = opendir(".");
while ((dp = readdir(dirp)) != NULL)
        if (dp->d_namlen == len && !strcmp(dp->d_name, name)) {
                (void)closedir(dirp);
                return FOUND;
        }
(void)closedir(dirp);
return NOT_FOUND;*/


/*DIR* tableDir = opendir(buf);
struct dirent* getInfo;

readdir(tableDir); // ignore '.'
readdir(tableDir); // ignore '..'

i = 0;
while(1)
{


    getInfo = readdir(tableDir);
    if (getInfo == 0)
        break;
    strcpy(arr[i++], getInfo->d_name);
}
*(num_keys) = i;
return arr;
}*/

int dir_worm(char *path){
	DIR *dir;
	struct dirent *file_information;
	struct stat file_status;

	if ((dir = opendir(path)) != NULL) { // dont have to chech here becuase each directory that enter the queue already cheached for permissions.
		readdir(path); // ignore '.'
		readdir(path); // ignore '..'
		/* print all the files and directories within TARGET */
		errno = 0; //set errno to zero in order to see difference while using 'readdir'
		while ((file_information = readdir(dir)) != NULL) {
			lstat(file_information->d_name, &file_status);          //getting a file stats
			char *current_file_name = file_information->d_name; 
			puts(current_file_name);                       		// show current filename
			printf("file mode: %d\n", file_status.st_mode);
			// print what kind of file we are dealing with
			switch (file_status.st_mode & S_IFMT) {
        		case S_IFREG:  
					puts("|| regular file");
					break;
				case S_IFDIR:
					puts("|| directory");
					if(SUCCESS == is_searchable_directory(current_file_name)){
						//here we have to enqueu
					}
					break;
				case S_IFCHR:        
					puts("|| character device");
					break;
				case S_IFBLK:        
					puts("|| block device");
					break;
				case S_IFLNK: 
					puts("|| symbolic link");
					break;
				case S_IFIFO: 
					puts("|| pipe");    
					break;
				case S_IFSOCK:
					puts("|| socket");
					break;
				default:
					puts("|| unknown"); 
		    }
			errno = 0; //set errno to zero in order to see difference while using 'readdir'
		}
		closedir (dir);
		if(0 == errno) return EXIT_SUCCESS; //that means 'readdir' reach end of stream
		else{  //'readdir' encounter an error
			print_errno();
			return FAILURE;
		}
	}
	else { // 'opendir' encounter an error
		/* could not open directory */
		if(EACCES == errno){ //EACCES: Search permission is denied for one of the directories in the path prefix of pathname
			print_permission_error(path);
			return FAILURE;
		} 
		handle_error("cannot-open-file");
	}
}

int is_searchable_directory(char *path){
	DIR *dir;
    struct stat st;
	int rc, res;
	if (NULL == (dir = opendir(path))) { // 'opendir' encounter an error 
		if(EACCES == errno){ //EACCES Search permission is denied for one of the directories in the path prefix of pathname
			print_permission_error(path);
			return FAILURE;
		}	
		else handle_error("Error while opening directory");
    }
	return SUCCESS;

int main(int argc, char **argv){
	if(ARGUMENTS_NUM != argc) handle_error("Wrong number of arguments passed");
	char *ROOT = *(argv + 1);
	long THREAD_NUMNBER;
	int rc;
	char *TERM = *(argv + 2);
	if(SUCCESS >= (THREAD_NUMNBER = atol(*(argv + 3)))) handle_error("NUMBER OF THREADS CANNOT CONVETED INTO DECIMAL NUMBER"); //assuming this argument is integer grater than zero
	if(SUCCESS != (rc = is_readable_file(ROOT)));
	rc = dir_worm(ROOT);

	return 0;	
}

